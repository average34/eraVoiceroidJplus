;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;「ぱんくしょん」110709版
;Emuera専用汎用関数ファイル。多少はバリアント間互換あり
;無断再配布ＯＫ、その際改変・追記は元の機能を損なわない範囲でお願いします
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;「基礎関数群」ファイル
;バリアント・テンプレを選ばずに使用できる簡単な関数が入っています。
;一般的な能力・素質名を使用しているバリアントの場合、ほぼ改変なしで使用することができます。
;一般向けのため、口上・パッチ作者様は目を通しておくとちょっと便利です。
;変更などで今まで使えた機能が使えなくなるということは多分ありません。
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠バリアント設定
;	引数：スコープの何番目の数字を使うかの設定
;ぱんくしょんが占有するCFLAGのスコープを設定します。LOCALに指定した番号から100のCFLAGを使用します
;デフォルトではCFLAG:7900から7999を使用
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
@PANCTION_CFLAG(ARG)
#FUNCTION

;デフォルトでは7900～7999
LOCAL = 7900

RETURNF LOCAL+ARG


;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠式中関数
;「#FUNCTION」属性をもち、式中で直接使用する関数です
;「IF PENIS(MASTER)」のように条件式、代入式に使用します
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;-------------------------------------------------
;真判定関数@TRUE
;	引数：対象の数字
;真であれば1を返します
;-------------------------------------------------
@TRUE(ARG)
#FUNCTION
RETURNF !(!ARG)

;-------------------------------------------------
;正判定関数@POSI
;	引数：対象の数字
;正であれば1を返します
;-------------------------------------------------
@POSI(ARG)
#FUNCTION
RETURNF ARG > 0

;-------------------------------------------------
;負判定関数@NEGA
;	引数：対象の数字
;負であれば1を返します
;-------------------------------------------------
@NEGA(ARG)
#FUNCTION
RETURNF ARG < 0

;-------------------------------------------------
;範囲判定関数@RANGE
;	引数0：対象の数字
;	引数1～2：範囲の上限・下限（逆順可）
;引数0が引数1と引数2の間に収まっていれば1を返します。ともに同値を許容します
;-------------------------------------------------
@RANGE(ARG, ARG:1, ARG:2)
#FUNCTION
SIF ARG:1 > ARG:2
	SWAP ARG:1, ARG:2
RETURNF ARG >= ARG:1 && ARG <= ARG:2

;-------------------------------------------------
;非調教者判定関数@NONPLAYER
;	引数：エラー対策オプション
;MASTERとASSIのうち、PLAYERでないほうのキャラ番号を返します
;引数が真なら、助手がいなければPLAYERの値で代替します。エラー落ちはしませんが誤作動の温床になります
;-------------------------------------------------
@NONPLAYER(ARG)
#FUNCTION
RETURNF PLAYER == MASTER ? (ARG && ASSI < 0 ? PLAYER # ASSI) # MASTER

;-------------------------------------------------
;ペニス判定関数@PENIS
;	引数：対象キャラの登録番号
;ペニスがある場合1を返します
;-------------------------------------------------
@PENIS(ARG)
#FUNCTION
SIF ARG < 0
	RETURNF 0
RETURNF TALENTCHECK(ARG, "オトコ") || TALENTCHECK(ARG, "ふたなり")

;-------------------------------------------------
;回復速度判定関数@VITALITY
;	引数：対象キャラの登録番号
;回復早いなら1、遅いなら-1を返します。差し引きするのでたぶんいろいろ勝手に対応します
;-------------------------------------------------
@VITALITY(ARG)
#FUNCTION
SIF ARG < 0
	RETURNF 0
RETURNF TALENTCHECK(ARG, "回復早い") - TALENTCHECK(ARG, "回復遅い")

;-------------------------------------------------
;主人調教判定関数@MASTERONLY
;	引数：判定したい素質名（文字列）
;TARGETが引数の素質を持っていて、かつ調教者が主人であれば1を返します
;恋慕で助手にまでデレる現象を避ける条件式を簡略化するものです
;文字列に誤りがある場合は警告のためエラー落ちします
;-------------------------------------------------
@MASTERONLY(ARGS)
#FUNCTION
RETURNF !ASSIPLAY && TALENT:(ARGS)

;--------------------------------------------------
;乱数判定関数@PERCENT
;	引数：判定する確率（0～100(％)）
;成否判定を行い、RESULTに判定成功=1、失敗=0を返します
;--------------------------------------------------
@PERCENT(ARG)
#FUNCTION
RETURNF ARG > RAND:100

;-------------------------------------------------
;ベース割合算出関数@BASERATIO
;	引数0：対象キャラの登録番号
;	引数1：ベース番号（BASE:番号）
;	引数2：正の場合、閾値（％）
;ベース値がMAXBASEの何％あるか返します
;引数2を設定した場合はその％以上なら真を返します
;-------------------------------------------------
@BASERATIO(ARG, ARG:1, ARG:2)
#FUNCTION
RETURNF ARG:2 ? (BASE:ARG:(ARG:1)*100)/MAXBASE:(ARG:1) >= ARG:2 # (BASE:ARG:(ARG:1)*100)/MAXBASE:(ARG:1)

;-------------------------------------------------
;助手素質判定関数@ASSITALENT
;	引数：TALENT番号
;助手の存在を確認してから、引数番号のTALENTの数値を返します
;条件式簡略化のため、助手がいない場合も0を返します
;「指定した素質を持つ助手がいるときに真になる」とご理解ください
;-------------------------------------------------
@ASSITALENT(ARG)
#FUNCTION
RETURNF ASSI >= 0 ? TALENT:ASSI:ARG # 0

;-------------------------------------------------
;助手能力判定関数@ASSIABL
;	引数：ABL番号
;助手の存在を確認してから、引数番号のABLの数値を返します
;条件式簡略化のため、助手がいない場合も0を返します
;-------------------------------------------------
@ASSIABL(ARG)
#FUNCTION
RETURNF ASSI >= 0 ? ABL:ASSI:ARG # 0

;-------------------------------------------------
;助手CFLAG判定関数@ASSICFLAG
;	引数：CFLAG番号
;助手の存在を確認してから、引数番号のCFLAGの数値を返します
;条件式簡略化のため、助手がいない場合も0を返します
;-------------------------------------------------
@ASSICFLAG(ARG)
#FUNCTION
RETURNF ASSI >= 0 ? CFLAG:ASSI:ARG # 0

;-------------------------------------------------
;助手番号判定関数@ASSINO
;助手の存在を確認してから、助手のNOを返します
;助手がいない場合は-1を返します
;NO:ASSIとの違いは、助手がいない場合にエラーにならないことです
;-------------------------------------------------
@ASSINO(ARG)
#FUNCTION
RETURNF ASSI >= 0 ? NO:ASSI # -1

;-------------------------------------------------
;数値→漢数字変換関数@TOKANJI
;TOSTR関数チックに、引数の数値を漢数字の文字列で返します
;変数の最大値は約922京であるため、一、万、億、兆、京の5回処理します
;-------------------------------------------------
@TOKANJI(ARG)
#FUNCTIONS
#DIM LCOUNT, 1
VARSET LOCALS
FOR LCOUNT, 0, 5
	LOCAL = ARG/POWER(10000, (4-LCOUNT))
	ARG %= POWER(10000, (4-LCOUNT))
	IF LOCAL
		LOCALS += TOKANJIT(LOCAL)
		SELECTCASE LCOUNT
			CASE 0
				LOCALS += "京"
			CASE 1
				LOCALS += "兆"
			CASE 2
				LOCALS += "億"
			CASE 3
				LOCALS += "万"
		ENDSELECT
	ENDIF
NEXT
RETURNF \@ LOCALS != "" ? %LOCALS% # 零 \@

;内部用or簡易用
;四桁以内の漢字変換。万以上与えるとバグ
@TOKANJIT(ARG)
#FUNCTIONS
SIF ARG >= 10000
	RETURNF "ばぐ"
LOCALS = \@ ARG/1000 ? %TOKANJIS(ARG/1000, 1)%千 # \@
ARG %= 1000
LOCALS += \@ ARG/100 ? %TOKANJIS(ARG/100, 1)%百 # \@
ARG %= 100
LOCALS += \@ ARG/10 ? %TOKANJIS(ARG/10, 1)%十 # \@
ARG %= 10
RETURNF LOCALS + TOKANJIS(ARG)


;一桁の変換。引数1を真にすると一を省略する。2以上にすると零を表示する
@TOKANJIS(ARG, ARG:1)
#FUNCTIONS
SELECTCASE ARG
	CASE 0
		RETURNF \@ ARG:1 > 1 ? 零 #  \@
	CASE 1
		RETURNF \@ ARG:1 ?  # 一 \@
	CASE 2
		RETURNF "二"
	CASE 3
		RETURNF "三"
	CASE 4
		RETURNF "四"
	CASE 5
		RETURNF "五"
	CASE 6
		RETURNF "六"
	CASE 7
		RETURNF "七"
	CASE 8
		RETURNF "八"
	CASE 9
		RETURNF "九"
	CASE 10
		RETURNF "十"
	CASEELSE
		RETURNF "ばぐ"
ENDSELECT

;-------------------------------------------------
;ORビットチェック関数@GETBITOR
;	引数0：チェックされる数値・変数
;	引数1～100：チェックするビット
;式中で使用する関数です。引数0の値で与えられた引数1～100番目のビットを見ます。いずれかが立っていれば1を返します
;引数0はチェックする対象、チェックされる数値は100まで引き受け可能
;チェック数値がすべて省略されるか不適切だと0が返ります
;-------------------------------------------------
@GETBITOR(ARG, ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1, ARG:10 = -1, ARG:11 = -1, ARG:12 = -1, ARG:13 = -1, ARG:14 = -1, ARG:15 = -1, ARG:16 = -1, ARG:17 = -1, ARG:18 = -1, ARG:19 = -1, ARG:20 = -1, ARG:21 = -1, ARG:22 = -1, ARG:23 = -1, ARG:24 = -1, ARG:25 = -1, ARG:26 = -1, ARG:27 = -1, ARG:28 = -1, ARG:29 = -1, ARG:30 = -1, ARG:31 = -1, ARG:32 = -1, ARG:33 = -1, ARG:34 = -1, ARG:35 = -1, ARG:36 = -1, ARG:37 = -1, ARG:38 = -1, ARG:39 = -1, ARG:40 = -1, ARG:41 = -1, ARG:42 = -1, ARG:43 = -1, ARG:44 = -1, ARG:45 = -1, ARG:46 = -1, ARG:47 = -1, ARG:48 = -1, ARG:49 = -1, ARG:50 = -1, ARG:51 = -1, ARG:52 = -1, ARG:53 = -1, ARG:54 = -1, ARG:55 = -1, ARG:56 = -1, ARG:57 = -1, ARG:58 = -1, ARG:59 = -1, ARG:60 = -1, ARG:61 = -1, ARG:62 = -1, ARG:63 = -1, ARG:64 = -1, ARG:65 = -1, ARG:66 = -1, ARG:67 = -1, ARG:68 = -1, ARG:69 = -1, ARG:70 = -1, ARG:71 = -1, ARG:72 = -1, ARG:73 = -1, ARG:74 = -1, ARG:75 = -1, ARG:76 = -1, ARG:77 = -1, ARG:78 = -1, ARG:79 = -1, ARG:80 = -1, ARG:81 = -1, ARG:82 = -1, ARG:83 = -1, ARG:84 = -1, ARG:85 = -1, ARG:86 = -1, ARG:87 = -1, ARG:88 = -1, ARG:89 = -1, ARG:90 = -1, ARG:91 = -1, ARG:92 = -1, ARG:93 = -1, ARG:94 = -1, ARG:95 = -1, ARG:96 = -1, ARG:97 = -1, ARG:98 = -1, ARG:99 = -1, ARG:100 = -1)
#FUNCTION
#DIM LCOUNT, 1
LOCAL = 0
FOR LCOUNT, 1, 100
	SIF ARG:LCOUNT < 0 || ARG:LCOUNT > 63
		RETURNF 0
	SIF GETBIT(ARG, ARG:LCOUNT)
		RETURNF 1
NEXT
RETURNF 0

;-------------------------------------------------
;配列ビットチェック関数@GETBITAR
;	引数0：チェックするビット
;	引数1～100：チェックされる数値・変数
;式中で使用する関数です。引数0の値番目のビットを引数1～100番目に対して見ます。いずれかで立っていれば1を返します
;GETBITOR等と比べて引数配置が逆になっています。また、便宜上配列と銘打ってますが配列をまとめて扱うことはできません
;チェック数値がすべて省略されるか不適切だと0が返ります
;-------------------------------------------------
@GETBITAR(ARG = -1 , ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1, ARG:10 = -1, ARG:11 = -1, ARG:12 = -1, ARG:13 = -1, ARG:14 = -1, ARG:15 = -1, ARG:16 = -1, ARG:17 = -1, ARG:18 = -1, ARG:19 = -1, ARG:20 = -1, ARG:21 = -1, ARG:22 = -1, ARG:23 = -1, ARG:24 = -1, ARG:25 = -1, ARG:26 = -1, ARG:27 = -1, ARG:28 = -1, ARG:29 = -1, ARG:30 = -1, ARG:31 = -1, ARG:32 = -1, ARG:33 = -1, ARG:34 = -1, ARG:35 = -1, ARG:36 = -1, ARG:37 = -1, ARG:38 = -1, ARG:39 = -1, ARG:40 = -1, ARG:41 = -1, ARG:42 = -1, ARG:43 = -1, ARG:44 = -1, ARG:45 = -1, ARG:46 = -1, ARG:47 = -1, ARG:48 = -1, ARG:49 = -1, ARG:50 = -1, ARG:51 = -1, ARG:52 = -1, ARG:53 = -1, ARG:54 = -1, ARG:55 = -1, ARG:56 = -1, ARG:57 = -1, ARG:58 = -1, ARG:59 = -1, ARG:60 = -1, ARG:61 = -1, ARG:62 = -1, ARG:63 = -1, ARG:64 = -1, ARG:65 = -1, ARG:66 = -1, ARG:67 = -1, ARG:68 = -1, ARG:69 = -1, ARG:70 = -1, ARG:71 = -1, ARG:72 = -1, ARG:73 = -1, ARG:74 = -1, ARG:75 = -1, ARG:76 = -1, ARG:77 = -1, ARG:78 = -1, ARG:79 = -1, ARG:80 = -1, ARG:81 = -1, ARG:82 = -1, ARG:83 = -1, ARG:84 = -1, ARG:85 = -1, ARG:86 = -1, ARG:87 = -1, ARG:88 = -1, ARG:89 = -1, ARG:90 = -1, ARG:91 = -1, ARG:92 = -1, ARG:93 = -1, ARG:94 = -1, ARG:95 = -1, ARG:96 = -1, ARG:97 = -1, ARG:98 = -1, ARG:99 = -1, ARG:100 = -1)
#FUNCTION
#DIM LCOUNT, 1
LOCAL = 0
SIF ARG < 0 || ARG > 63
	RETURNF 0
FOR LCOUNT, 1, 100
	SIF ARG:LCOUNT < 0
		RETURNF 0
	SIF GETBIT(ARG:LCOUNT, ARG)
		RETURNF 1
NEXT
RETURNF 0

;-------------------------------------------------
;ANDビットチェック関数@GETBITAND
;	引数0：チェックされる数値・変数
;	引数1～100：チェックするビット
;式中で使用する関数です。引数0の値で与えられた引数1～100番目のビットを見ます。すべて立っていれば1を返します
;引数0はチェックする対象、チェックされる数値は100まで引き受け可能
;チェック数値がすべて省略されるか不適切だと1が返ります
;-------------------------------------------------
@GETBITAND(ARG, ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1, ARG:10 = -1, ARG:11 = -1, ARG:12 = -1, ARG:13 = -1, ARG:14 = -1, ARG:15 = -1, ARG:16 = -1, ARG:17 = -1, ARG:18 = -1, ARG:19 = -1, ARG:20 = -1, ARG:21 = -1, ARG:22 = -1, ARG:23 = -1, ARG:24 = -1, ARG:25 = -1, ARG:26 = -1, ARG:27 = -1, ARG:28 = -1, ARG:29 = -1, ARG:30 = -1, ARG:31 = -1, ARG:32 = -1, ARG:33 = -1, ARG:34 = -1, ARG:35 = -1, ARG:36 = -1, ARG:37 = -1, ARG:38 = -1, ARG:39 = -1, ARG:40 = -1, ARG:41 = -1, ARG:42 = -1, ARG:43 = -1, ARG:44 = -1, ARG:45 = -1, ARG:46 = -1, ARG:47 = -1, ARG:48 = -1, ARG:49 = -1, ARG:50 = -1, ARG:51 = -1, ARG:52 = -1, ARG:53 = -1, ARG:54 = -1, ARG:55 = -1, ARG:56 = -1, ARG:57 = -1, ARG:58 = -1, ARG:59 = -1, ARG:60 = -1, ARG:61 = -1, ARG:62 = -1, ARG:63 = -1, ARG:64 = -1, ARG:65 = -1, ARG:66 = -1, ARG:67 = -1, ARG:68 = -1, ARG:69 = -1, ARG:70 = -1, ARG:71 = -1, ARG:72 = -1, ARG:73 = -1, ARG:74 = -1, ARG:75 = -1, ARG:76 = -1, ARG:77 = -1, ARG:78 = -1, ARG:79 = -1, ARG:80 = -1, ARG:81 = -1, ARG:82 = -1, ARG:83 = -1, ARG:84 = -1, ARG:85 = -1, ARG:86 = -1, ARG:87 = -1, ARG:88 = -1, ARG:89 = -1, ARG:90 = -1, ARG:91 = -1, ARG:92 = -1, ARG:93 = -1, ARG:94 = -1, ARG:95 = -1, ARG:96 = -1, ARG:97 = -1, ARG:98 = -1, ARG:99 = -1, ARG:100 = -1)
#FUNCTION
#DIM LCOUNT, 1
LOCAL = 0
FOR LCOUNT, 1, 100
	SIF ARG:LCOUNT < 0 || ARG:LCOUNT > 63
		RETURNF 1
	SIF !GETBIT(ARG, ARG:LCOUNT)
		RETURNF 0
NEXT
RETURNF 1

;-------------------------------------------------
;除外ビットチェック関数@GETBITEX
;	引数0：チェックされる数値・変数
;	引数1～100：チェックするビット
;式中で使用する関数です。引数0の値で与えられた引数1～100番目のビットを見ます。それらのビット以外に何か立っていれば真になります
;それらのビットが立っているかどうか自体は見ないので、見たい場合はGETBITORを併用してください
;引数0はチェックする対象、チェックされる数値は100まで引き受け可能
;チェック数値がすべて省略されるか不適切だと1が返ります
;-------------------------------------------------
@GETBITEX(ARG, ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1, ARG:10 = -1, ARG:11 = -1, ARG:12 = -1, ARG:13 = -1, ARG:14 = -1, ARG:15 = -1, ARG:16 = -1, ARG:17 = -1, ARG:18 = -1, ARG:19 = -1, ARG:20 = -1, ARG:21 = -1, ARG:22 = -1, ARG:23 = -1, ARG:24 = -1, ARG:25 = -1, ARG:26 = -1, ARG:27 = -1, ARG:28 = -1, ARG:29 = -1, ARG:30 = -1, ARG:31 = -1, ARG:32 = -1, ARG:33 = -1, ARG:34 = -1, ARG:35 = -1, ARG:36 = -1, ARG:37 = -1, ARG:38 = -1, ARG:39 = -1, ARG:40 = -1, ARG:41 = -1, ARG:42 = -1, ARG:43 = -1, ARG:44 = -1, ARG:45 = -1, ARG:46 = -1, ARG:47 = -1, ARG:48 = -1, ARG:49 = -1, ARG:50 = -1, ARG:51 = -1, ARG:52 = -1, ARG:53 = -1, ARG:54 = -1, ARG:55 = -1, ARG:56 = -1, ARG:57 = -1, ARG:58 = -1, ARG:59 = -1, ARG:60 = -1, ARG:61 = -1, ARG:62 = -1, ARG:63 = -1, ARG:64 = -1, ARG:65 = -1, ARG:66 = -1, ARG:67 = -1, ARG:68 = -1, ARG:69 = -1, ARG:70 = -1, ARG:71 = -1, ARG:72 = -1, ARG:73 = -1, ARG:74 = -1, ARG:75 = -1, ARG:76 = -1, ARG:77 = -1, ARG:78 = -1, ARG:79 = -1, ARG:80 = -1, ARG:81 = -1, ARG:82 = -1, ARG:83 = -1, ARG:84 = -1, ARG:85 = -1, ARG:86 = -1, ARG:87 = -1, ARG:88 = -1, ARG:89 = -1, ARG:90 = -1, ARG:91 = -1, ARG:92 = -1, ARG:93 = -1, ARG:94 = -1, ARG:95 = -1, ARG:96 = -1, ARG:97 = -1, ARG:98 = -1, ARG:99 = -1, ARG:100 = -1)
#FUNCTION
#DIM LCOUNT, 1
VARSET LOCAL, -1
FOR LCOUNT, 1, 100
	SIF ARG:LCOUNT < 0 || ARG:LCOUNT > 63
		RETURNF ARG
	CLEARBIT ARG, ARG:LCOUNT
NEXT
RETURNF ARG

;-------------------------------------------------
;真値集計関数@TRUECHECK
;	引数0～19：集計対象
;引数のうち真になるものがいくつあるかを数えます
;-------------------------------------------------
@TRUECHECK(ARG, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19, ARG:20, ARG:21, ARG:22, ARG:23, ARG:24, ARG:25, ARG:26, ARG:27, ARG:28, ARG:29, ARG:30, ARG:31, ARG:32, ARG:33, ARG:34, ARG:35, ARG:36, ARG:37, ARG:38, ARG:39, ARG:40, ARG:41, ARG:42, ARG:43, ARG:44, ARG:45, ARG:46, ARG:47, ARG:48, ARG:49, ARG:50, ARG:51, ARG:52, ARG:53, ARG:54, ARG:55, ARG:56, ARG:57, ARG:58, ARG:59, ARG:60, ARG:61, ARG:62, ARG:63, ARG:64, ARG:65, ARG:66, ARG:67, ARG:68, ARG:69, ARG:70, ARG:71, ARG:72, ARG:73, ARG:74, ARG:75, ARG:76, ARG:77, ARG:78, ARG:79, ARG:80, ARG:81, ARG:82, ARG:83, ARG:84, ARG:85, ARG:86, ARG:87, ARG:88, ARG:89, ARG:90, ARG:91, ARG:92, ARG:93, ARG:94, ARG:95, ARG:96, ARG:97, ARG:98, ARG:99)
#FUNCTION
LOCAL = 0
FOR LOCAL:100, 0, 100
	SIF ARG:(LOCAL:100) > 0
		LOCAL ++
NEXT
RETURNF LOCAL

;--------------------------------------------------
;おっぱい比較関数@BUSTSIZE
;	引数0：比較対象１の登録番号
;	引数1：比較対象２の登録番号
;引数で渡された２キャラの胸の大きさを素質で比較します
;どちらかがオトコか不在なら0、引数0のキャラが大きいなら1、引数1のキャラが大きいなら2、同じなら3が返ります
;--------------------------------------------------
@BUSTSIZE(ARG, ARG:1)
#FUNCTION
SIF ARG < 0 || ARG:1 < 0
	RETURNF 0
SIF TALENTCHECK(ARG, "オトコ") || TALENTCHECK(ARG:1, "オトコ")
	RETURNF 0
IF TALENTCHECK(ARG, "爆乳")
	SIF TALENTCHECK(ARG:1, "爆乳")
		RETURNF 3
	RETURNF 1
ELSEIF TALENTCHECK(ARG, "巨乳")
	SIF TALENTCHECK(ARG:1, "爆乳")
		RETURNF 2
	SIF TALENTCHECK(ARG:1, "巨乳")
		RETURNF 3
	RETURNF 1
ELSEIF TALENTCHECK(ARG, "絶壁")
	SIF TALENTCHECK(ARG:1, "絶壁")
		RETURNF 3
	RETURNF 2
ELSEIF TALENTCHECK(ARG, "貧乳")
	SIF TALENTCHECK(ARG:1, "絶壁")
		RETURNF 1
	SIF TALENTCHECK(ARG:1, "貧乳")
		RETURNF 3
	RETURNF 2
ELSE
	SIF TALENTCHECK(ARG:1, "絶壁") || TALENTCHECK(ARG:1, "貧乳")
		RETURNF 1
	SIF TALENTCHECK(ARG:1, "爆乳") || TALENTCHECK(ARG:1, "巨乳")
		RETURNF 2
	RETURNF 3
ENDIF

;--------------------------------------------------
;おっぱい参照関数@GETBUST
;	引数0：キャラ登録番号
;引数キャラの胸の大きさを数字（-2から2）で取得します。貧乳、絶壁なら-1、-2を返すので真偽式にしないでください
;--------------------------------------------------
@GETBUST(ARG)
#FUNCTION
SIF ARG < 0 || TALENTCHECK(ARG, "オトコ")
	RETURNF 0
IF TALENTCHECK(ARG, "爆乳")
	RETURNF 2
ELSEIF TALENTCHECK(ARG, "巨乳")
	RETURNF 1
ELSEIF TALENTCHECK(ARG, "絶壁")
	RETURNF -2
ELSEIF TALENTCHECK(ARG, "貧乳")
	RETURNF -1
ELSE
	RETURNF 0
ENDIF

;--------------------------------------------------
;性感帯参照関数@FAV_FEEL
;	引数：対象キャラの登録番号
;対象キャラの好きな性感帯を返します
;性感帯別陥落素質（尻穴狂い等）があると無条件に優先されます
;～敏感、～鈍感はそれぞれ該当感覚Lvを±1.5補正し、ふたなり・オトコはCを+1補正します
;同じ数字の場合、V、C、A、Bの順で優先します
;戻り値0ならどの感覚も2未満、1ならC、2はV、3はA、4はB性感が好きであることを意味します。
;引数1と引数2を指定すると、引数1の部位の感覚が2より好きである場合真を返します。同値は引数1を優先
;引数1,2=(0=C、1=V、2=A、3=B)
;--------------------------------------------------
@FAV_FEEL(ARG, ARG:1 = -1, ARG:2 = -1)
#FUNCTION
;性感帯別陥落素質を参照する
SIF TALENTCHECK(ARG, "淫壷") && !TALENTCHECK(ARG, "オトコ")
	RETURNF 2
SIF TALENTCHECK(ARG, "淫核／淫茎") || TALENTCHECK(ARG, "淫核") || TALENTCHECK(ARG, "淫茎")
	RETURNF 1
SIF TALENTCHECK(ARG, "淫尻") || TALENTCHECK(ARG, "尻穴狂い")
	RETURNF 3
SIF TALENTCHECK(ARG, "淫乳")
	RETURNF 4

;各感覚をLOCAL0～3にコピーして10倍に
LOCAL = (ABLCHECK(ARG, "Ｃ感覚"))*10
LOCAL:1 = (ABLCHECK(ARG, "Ｖ感覚"))*10
LOCAL:2 = (ABLCHECK(ARG, "Ａ感覚"))*10
LOCAL:3 = (ABLCHECK(ARG, "Ｂ感覚"))*10

;各敏感・鈍感・ふたなり・オトコの処理
IF TALENTCHECK(ARG, "Ｃ鈍感")
	LOCAL -= 15
ELSEIF TALENTCHECK(ARG, "Ｃ敏感")
	LOCAL += 15
ENDIF
SIF PENIS(ARG)
	LOCAL += 10
IF TALENTCHECK(ARG, "Ｖ鈍感")
	LOCAL:1 -= 15
ELSEIF TALENTCHECK(ARG, "Ｖ敏感")
	LOCAL:1 += 15
ENDIF
IF TALENTCHECK(ARG, "Ａ鈍感")
	LOCAL:2 -= 15
ELSEIF TALENTCHECK(ARG, "Ａ敏感")
	LOCAL:2 += 15
ENDIF
IF TALENTCHECK(ARG, "Ｂ鈍感")
	LOCAL:3 -= 15
ELSEIF TALENTCHECK(ARG, "Ｂ敏感")
	LOCAL:3 += 15
ENDIF

;条件比較
SIF ARG:1 >= 0 && ARG:2 >= 0
	RETURNF LOCAL:(ARG:1) >= LOCAL:(ARG:2)

;すべて2未満の場合
SIF LOCAL < 20 && LOCAL:1 < 20 && LOCAL:2 < 20 && LOCAL:3 < 20
	RETURNF 0

;比較
IF LOCAL:1 >= LOCAL && LOCAL:1 >= LOCAL:2 && LOCAL:1 >= LOCAL:3 && !TALENTCHECK(ARG, "オトコ")
	RETURNF 2
ELSEIF LOCAL >= LOCAL:2 && LOCAL >= LOCAL:3
	RETURNF 1
ELSEIF LOCAL:2 >= LOCAL:3
	RETURNF 3
ELSE
	RETURNF 4
ENDIF

;-------------------------------------------------
;RGB色指定関数@RGBCOLOR
;	引数0：Ｒ輝度（0～255）
;	引数1：Ｇ輝度（0～255）
;	引数2：Ｂ輝度（0～255）
;式中で使用する関数です。引数0～3でRGBを指定すると、16進（0xRRGGBB）にして返します
;-------------------------------------------------
;@RGBCOLOR(ARG, ARG:1, ARG:2)
;#FUNCTION
;LOCAL = GETCOLOR()
;SETCOLOR ARG, ARG:1, ARG:2
;LOCAL:1 = GETCOLOR()
;SETCOLOR LOCAL
;RETURNF LOCAL:1

;-------------------------------------------------
;幻想暦関数@GENSOU_CALENDAR
;	引数0：2000年1月1日（115季睦月一日）からの経過日数
;引数に経過日数を与えることで、幻想卿の暦を文字列で返す関数です
;-------------------------------------------------
@GENSOU_CALENDAR(ARG)
#FUNCTIONS
;LOCALに年数
LOCAL = GETYEAR(ARG)
;LOCAL:1に月数
LOCAL:1 = GETDATE(GETYEAR(ARG, 1), GETURUU(LOCAL))
;LOCAL:2に日数
LOCAL:2 = GETDATE(GETYEAR(ARG, 1), GETURUU(LOCAL), 1)

RETURNF @"第%TOKANJI(LOCAL+115)%季　%GETMONTHNAME(LOCAL:1)%の%TOKANJI(LOCAL:2)%"

;-------------------------------------------------
;閏年判定関数@GETURUU
;	引数0：年数
;西暦で年数を与えるとその年の日数を返します
;-------------------------------------------------
@GETURUU(ARG)
#FUNCTION
RETURNF (!(ARG % 4) && (ARG % 100)) || !(ARG % 400) ? 366 # 365

;-------------------------------------------------
;年数判定関数@GETYEAR
;	引数0：2000年1月1日からの経過日数
;	引数1：1にすると、端日数を返します
;経過日数から、経過年数を返します。
;引数1を真にすると、現在の年で何日経過しているかを返します。
;2000年を0年として返すため、西暦表記する際は2000を足してください。
;単純に経過年数を数える場合は意識しなくてもＯＫ
;-------------------------------------------------
@GETYEAR(ARG, ARG:1)
#FUNCTION
VARSET LOCAL
;2000年を0年目として扱う
;2000年から順に回して、年数LOCALを増やす
WHILE ARG > GETURUU(LOCAL)
	LOCAL++
	ARG -= GETURUU(LOCAL)
WEND
RETURNF ARG:1 ? ARG # LOCAL

;-------------------------------------------------
;日付判定関数@GETDATE
;	引数0：年内経過日数（年内総日数を超えるときはエラー…にはせず、総日数で割った余りで計算する。でもやめてね？）
;	引数1：年内総日数（GETURUU併用推奨）
;	引数2：省略すると○月、真にすると○日を返します
;-------------------------------------------------
@GETDATE(ARG, ARG:1 = 365, ARG:2)
#FUNCTION
;念のための処理
ARG %= ARG:1
;月ごとの日数計算
FOR LOCAL, 1, 13
	SELECTCASE LOCAL
		;30日の月
		CASE 4, 6, 9, 11
			LOCAL:1 = 30
		;2月
		CASE 2
			LOCAL:1 = 28 + (ARG:2 == 366)
		;31日の月
		CASEELSE
			LOCAL:1 = 31
	ENDSELECT
	IF ARG > LOCAL:1
		ARG -= LOCAL:1
	ELSE
		BREAK
	ENDIF
NEXT
RETURNF ARG:2 ? ARG # LOCAL-1

;-------------------------------------------------
;月名変換関数@GETMONTHNAME
;	引数0：ｎ月のｎ
;旧暦の月名に変換するだけ！
;12を超えていたら勝手に12で割って計算します。
;-------------------------------------------------
@GETMONTHNAME(ARG)
#FUNCTIONS
;念のための処理
ARG %= 12
SELECTCASE ARG
	CASE 1
		RETURNF "睦月"
	CASE 2
		RETURNF "役"
	CASE 3
		RETURNF "弥生"
	CASE 4
		RETURNF "卯月"
	CASE 5
		RETURNF "皐月"
	CASE 6
		RETURNF "水無月"
	CASE 7
		RETURNF "文月"
	CASE 8
		RETURNF "葉月"
	CASE 9
		RETURNF "長月"
	CASE 10
		RETURNF "神無月"
	CASE 11
		RETURNF "霜月"
	CASEELSE
		RETURNF "師走"
ENDSELECT

;-------------------------------------------------
;古典時刻関数@CLASSICAL_TIME
;	引数0：対象の変数（デフォでは秒）
;	引数1：1なら引数0を秒で、2なら時で計算する
;	引数2：表示形式（デフォ「○の○つ」、1=「○の刻、○つ」、2=「○の○つ　-○○-」）
;式中で使用する関数です。引数に記録されている数字を秒として、現在の時刻を文字列で返します
;古典時刻表記なので、30分単位未満の端数は切り捨てます。
;-------------------------------------------------
@CLASSICAL_TIME(ARG, ARG:1, ARG:2)
#FUNCTIONS
;分に変換する
SELECTCASE ARG:1
	;時で渡す場合
	CASE 2
		ARG *= 60
	;秒で渡す場合
	CASE 1
		ARG /= 60
ENDSELECT
;0:00が子の三つなので、60分を足す
ARG += 60
;日付も管理しているケースを考え、24時間（1440分）で割ってあまりを取る（子の一つ～二つもここで対応される）
ARG %= 1440
;表示
SIF GET_CLASSICAL_HOUR(ARG, 1) == "丑" && (ARG%120)/30 == 2
	RETURNF "丑三つ時"
RETURNF @"%GET_CLASSICAL_HOUR(ARG, 1)%の\@ ARG:2 == 1 ? 刻、 # \@%TOKANJI(((ARG%120)/30)+1)%つ\@ ARG:2 == 2 ? 　-%GET_CLASSICAL_HOUR(ARG, 1, 1)%時- # \@"

;時を取得
;引数2を真にすると、大まかな時間の様子を取る
@GET_CLASSICAL_HOUR(ARG, ARG:1, ARG:2)
#FUNCTIONS
;分に変換する
SELECTCASE ARG:1
	;時で渡す場合
	CASE 2
		ARG *= 60
	;分で渡す場合（処理なし）
	CASE 1
	;秒で渡す場合（デフォルト）
	CASEELSE
		ARG /= 60
ENDSELECT

SELECTCASE ARG/120
	CASE 0
		RETURNF \@ ARG:2 ? 深更（しんこう） # 子 \@
	CASE 1
		RETURNF \@ ARG:2 ? 未明（みめい） # 丑 \@
	CASE 2
		RETURNF \@ ARG:2 ? 東雲（しののめ） # 寅 \@
	CASE 3
		RETURNF \@ ARG:2 ? 暁（あかつき） # 卯 \@
	CASE 4
		RETURNF \@ ARG:2 ? 早天（そうてん） # 辰 \@
	CASE 5
		RETURNF \@ ARG:2 ? 小昼（こひる） # 巳 \@
	CASE 6
		RETURNF \@ ARG:2 ? 昼中（ひるなか） # 午 \@
	CASE 7
		RETURNF \@ ARG:2 ? 日盛り（ひざかり） # 未 \@
	CASE 8
		RETURNF \@ ARG:2 ? 終日（ひねもす） # 申 \@
	CASE 9
		RETURNF \@ ARG:2 ? 黄昏（たそがれ） # 酉 \@
	CASE 10
		RETURNF \@ ARG:2 ? 宵（よい） # 戌 \@
	CASE 11
		RETURNF \@ ARG:2 ? 夜半（よわ） # 亥 \@
ENDSELECT

;-------------------------------------------------
;文字列整列関数@UNITCELL
;	文字列引数：セルに入れる文字列
;	引数0：区切り文字数（PRINTCの文字数+1が望ましい）
;指定文字数に合わせて半角スペースを付与します。
;PRINTCとの違いは、指定文字数を超えた場合、指定文字数の２倍、３倍で区切る点です
;PRINTCと併用して横２セル結合みたいな表示ができます
;-------------------------------------------------
;@UNITCELL(ARGS, ARG)
;#FUNCTIONS
;RETURNF @"%ARGS+(" "*(ARG-(STRLENS(ARGS)%ARG)))%"

;;こちらは余った分はカットします。
;@FIXEDCELL(ARGS, ARG)
;#FUNCTIONS
;RETURNF \@ STRLENS(ARGS) > ARG ? %SUBSTRING(ARGS, 0, ARG-2)%.. # %ARGS+" "*(ARG-(STRLENS(ARGS)))% \@


;-------------------------------------------------------------------------------
;	Crow様作関数群より。ぱくりんくしょん
;-------------------------------------------------------------------------------
;	お金の表示 
;-------------------------------------------------------------------------------
;	例   12(MONEY:0) = 12銭
;	   1234(MONEY:0) = 12円34銭
;	   3000(MONEY:0) = 30円
;
;	※通貨価値は明治時代から隔離ということや
;	  原作を勘案して幻想郷1円(100銭) == 現代の2000円 を想定
;===============================================================================
;ARG = お金 (MONEYとかITEMPRICEとかで使用することを想定)
@PRINT_MONEY(ARG)
#FUNCTIONS
#LOCALSSIZE 2
VARSET LOCALS
SIF ARG == 0
	LOCALS = なし
SIF ARG >= 100
	LOCALS = {ARG/100}円
SIF ARG % 100
	LOCALS:1 = {ARG%100}銭
RETURNF LOCALS + LOCALS:1

;-------------------------------------------------------------------------------
;    BARの色違え版
;-------------------------------------------------------------------------------
;    引数はBARとほぼ一緒 + ARGSで描写文字の変更が可能(指定しない場合はBARと同じ仕様)
;    ARG:3はバーの色(0xFFFFFF形式で指定),ARG:4はバーの背景色(0xFFFFFF形式で指定)
;===============================================================================
;@PRINT_COLORBAR(ARG, ARG:1, ARG:2, ARGS = "*", ARGS:1 = ".", ARG:3, ARG:4)
;#LOCALSIZE 5
;VARSET LOCAL
;LOCAL:1 = ARG * ARG:2 / ARG:1
;LOCAL:2 = GETCOLOR()
;FOR LOCAL, 1, ARG:2 + 1
;	IF LOCAL:1 >= LOCAL
;		IF !LOCAL:3
;			SETCOLOR ARG:3
;			LOCAL:3 = 1
;		ENDIF
;		PRINTFORM %ARGS%
;	ELSE
;		IF !LOCAL:4
;			SETCOLOR ARG:4
;			LOCAL:4 = 1
;		ENDIF
;		PRINTFORM %ARGS:1%
;	ENDIF
;NEXT
;SETCOLOR LOCAL:2


;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠初回判定系関数
;式中関数の一種で、初めて呼ばれたときだけ真になる、というタイプの関数群
;CFLAGスコープ0～20を使用し、フラグ節約と代入の省略に機能します
;「IF FIRSTTIME(0)」や、「IF FIRSTCOM(SELECTCOM)」のように使用することで分岐が容易になります
;	共通の引数
;	引数0：イベント・コマンド番号
;	引数1：対象キャラの簡易指定（0=TARGET, 1=MASTER, 2=ASSI, 3=引数2で指定したキャラ）
;	引数2：引数1が=3のとき、対象キャラの登録番号
;	引数3以降は内部的に用いるものなので省略すること
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;-------------------------------------------------
;未読判定関数@FIRSTTIME
;CFLAGスコープ0～3を利用し、イベント番号0～251までの任意な初回判定を管理します
;調教前後などの会話イベントの初回判定に使用することを想定しています
;-------------------------------------------------
@FIRSTTIME(ARG, ARG:1, ARG:2, ARG:3)
#FUNCTION
RETURNF FIRSTTIME_PROCESS(PANCTION_CFLAG(0), 4, ARG, ARG:1, ARG:2, ARG:3)

;-------------------------------------------------
;未読参照関数@FIRSTTIMECHECK
;@FIRSTTIMEの初回判定を更新せずに参照だけを行います
;-------------------------------------------------
@FIRSTTIMECHECK(ARG, ARG:1, ARG:2)
#FUNCTION
RETURNF FIRSTTIME(ARG, ARG:1, ARG:2, 1)

;-------------------------------------------------
;コマンド初回判定関数@FIRSTCOM
;CFLAGスコープ4～19を利用し、コマンド番号0～1007までの任意な初回判定を管理します
;調教コマンド（SELECTCOM等）を直接渡し、コマンドの初回判定に使用することを想定しています
;-------------------------------------------------
@FIRSTCOM(ARG, ARG:1, ARG:2, ARG:3)
#FUNCTION
RETURNF FIRSTTIME_PROCESS(PANCTION_CFLAG(4), 16, ARG, ARG:1, ARG:2, ARG:3)

;-------------------------------------------------
;コマンド初回参照関数@FIRSTCOMCHECK
;@FIRSTCOMの初回判定を更新せずに参照だけを行います
;-------------------------------------------------
@FIRSTCOMCHECK(ARG, ARG:1, ARG:2)
#FUNCTION
RETURNF FIRSTCOM(ARG, ARG:1, ARG:2, 1)

;-------------------------------------------------
;調教内初回関数@ONCEPLAY
;CFLAGを用いず、キャラ登録番号0～999ごとにイベント番号0～63までの任意な調教内初回判定を管理します
;デフォルトだと@EVENTTRAINで初回判定をリセットしてすべて未読に戻します（対応できないバリアントもある）
;その日（ターン）で一度目だけ見られる反応などを設定するために使用することを想定しています
;-------------------------------------------------
@ONCEPLAY(ARG, ARG:1, ARG:2, ARG:3, ARG:4)
#FUNCTION
IF !ARG:1
	ARG:2 = TARGET
ELSEIF ARG:1 == 1
	ARG:2 = MASTER
ELSEIF ARG:1 == 2
	ARG:2 = ASSI
ENDIF
;規定の数を超えるか負か対象キャラがいないなら0を返す
SIF ARG >= 64 || ARG < 0 || ARG:2 >= CHARANUM
	RETURNF 0

;引数4が1か2だとフラグリセット処理のみ行う
IF ARG:4 == 2
	FOR ARG:10, 0, 1000
		LOCAL:(ARG:10) = 0
	NEXT
	RETURNF 0
ELSEIF ARG:4 == 1
	LOCAL:(ARG:2) = 0
	RETURNF 0
ENDIF

IF !GETBIT(LOCAL:(ARG:2), ARG)
	SIF !ARG:3
		SETBIT LOCAL:(ARG:2), ARG
	RETURNF 1
ENDIF
RETURNF 0

;-------------------------------------------------
;クリアチェック関数@GLOBALEVENT
;変数GLOBALを利用してクリアチェックを行います。GLOBAL1つにつきイベント番号0～63まで管理可能
;GLOBAL:1000～1999を使用
;通常
;	引数0：キャラ番号
;	引数1：イベント番号
;	引数2：真だとクリアチェックを更新せず参照のみ
;	引数3：真だとGLOBALのセーブロードを飛ばす
;-------------------------------------------------
@GLOBALEVENT(ARG, ARG:1, ARG:2, ARG:3)
#FUNCTION
;規定の数を超えるか負なら0を返す
SIF ARG:1 >= 64 || ARG < 0
	RETURNF 0
LOCAL = 0
ARG += 1000
SIF !ARG:3
	CALLF SINGLELOADG(ARG)
IF !GETBIT(GLOBAL:ARG, ARG:1)
	SIF !ARG:2
		SETBIT GLOBAL:ARG, ARG:1
	LOCAL = 1
ENDIF
SIF !ARG:3
	CALLF SINGLESAVEG(ARG)
RETURNF LOCAL
;-------------------------------------------------
;クリアチェック参照関数@GLOBALREAD
;@GLOBALEVENTの初回判定を更新せずに参照だけを行います
;そのイベントを見ていれば1、未読なら0を返します
;-------------------------------------------------
@GLOBALREAD(ARG, ARG:1)
#FUNCTION
RETURNF !GLOBALEVENT(ARG, ARG:1, 1)

;-------------------------------------------------
;クリアチェックカウント関数@GLOBALEVENTCHECK
;	引数2：引数1からイベントいくつ分か
;@GLOBALEVENTの初回判定を更新せずに参照だけを行います
;引数1から引数2の数分だけの範囲から、既読のイベントの数を返します
;-------------------------------------------------
@GLOBALEVENTCHECK(ARG, ARG:1, ARG:2, ARG:3)
#FUNCTION
VARSET LOCAL, 0
SIF !ARG:3
	CALLF SINGLELOADG(ARG+1000)
FOR LOCAL, ARG:1, ARG:1+ARG:2
	SIF !GLOBALEVENT(ARG, LOCAL, 1, 1)
		LOCAL:1 ++
NEXT

RETURNF LOCAL:1

;-------------------------------------------------
;クリアチェック実行関数@GLOBALWRITE
;@GLOBALEVENTの初回判定の更新を行います。一般関数です
;-------------------------------------------------
@GLOBALWRITE(ARG, ARG:1)
RETURN GLOBALEVENT(ARG, ARG:1)

;--------------------------------------------------
;グローバル書き込み関数@SINGLESAVEG
;	引数0：GLOBALの番号
;	引数1：軽量化オプション（未保存GLOBALを破棄する）
;仕様上、少々動作が重いため軽量化無しでの多用は推奨されません
;軽量化すると思わぬバグの原因となり得るので、濫用は推奨されません。というかSAVEGLOBALすれば済む話だこれ
;指定した番号のGLOBALのみをSAVEし、それ以外は全て元の（未保存状態の）ままにする式中関数です
;保存されているGLOBALと現在のGLOBALが異なっていても、SAVEを壊さずに現在のGLOBALに復元します
;ただし、引数1を真にするとこの配慮を行わず動作軽量化します（保存してあるGLOBALの状態に戻る。通常はこれで十分）
;テンポラリフラグを使用します。戻り値は保存済みのGLOBALと違う値だった（値を更新した）場合1、同じなら0です
;--------------------------------------------------
@SINGLESAVEG(ARG, ARG:1)
#FUNCTION
IF !ARG:1
	;テンポラリ初期化
	CALLF TEMPRESETALL(0)
	;現在のGLOBALをテンポラリへ逃がす
	FOR LOCAL, 0, VARSIZE("GLOBAL")
		SIF GLOBAL:LOCAL
			CALLF TEMPSET(LOCAL, GLOBAL:LOCAL)
	NEXT
ELSE
	CALLF TEMPSET(ARG, GLOBAL:ARG)
ENDIF

;GLOBAL読み込み
LOADGLOBAL
LOCAL:1 = GLOBAL:ARG
;指定した番号のみテンポラリから引いてくる
GLOBAL:ARG = TEMPFLAG(ARG)

;GLOBAL保存
SAVEGLOBAL

IF !ARG:1
	;未保存GLOBALを元に戻す
	FOR LOCAL, 0, VARSIZE("GLOBAL")
		GLOBAL:LOCAL = TEMPFLAG(LOCAL)
	NEXT
ENDIF

RETURNF LOCAL:1 != GLOBAL:ARG

;--------------------------------------------------
;グローバル読み込み関数@SINGLELOADG
;	引数：GLOBALの番号
;仕様上、少々動作が重いため多用は推奨されません
;指定した番号のGLOBALのみをLOADし、それ以外は全て元の（未保存状態の）ままにする式中関数です
;保存されているGLOBALと現在のGLOBALが異なっていても、SAVEを壊さずに現在のGLOBALに復元します
;テンポラリフラグを使用します。戻り値は読み込んだGLOBALの値です
;--------------------------------------------------
@SINGLELOADG(ARG)
#FUNCTION
;テンポラリ初期化
CALLF TEMPRESETALL(0)
;現在のGLOBALをテンポラリへ逃がす
FOR LOCAL, 0, VARSIZE("GLOBAL")
	SIF GLOBAL:LOCAL
		CALLF TEMPSET(LOCAL, GLOBAL:LOCAL)
NEXT

;GLOBAL読み込み
LOADGLOBAL

;指定した番号以外をテンポラリから引いてくる
FOR LOCAL, 0, VARSIZE("GLOBAL")
	SIF LOCAL != ARG
		GLOBAL:LOCAL = TEMPFLAG(LOCAL)
NEXT

RETURNF GLOBAL:ARG

;-------------------------------------------------
;調教内初回参照関数@ONCEPLAYCHECK
;@ONCEPLAYの初回判定を更新せずに参照だけを行います
;-------------------------------------------------
@ONCEPLAYCHECK(ARG, ARG:1, ARG:2)
#FUNCTION
RETURNF ONCEPLAY(ARG, ARG:1, ARG:2, 1)


;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠テンポラリフラグ系関数
;LOCALでは足りない、欲張りな貴方に
;好き勝手な書き換えができる一時フラグ用の関数です、@TEMPFLAG_0～9のLOCAL配列を利用
;もちろん好き勝手な書き換えもされるので制御を他に渡したら保存されていることを期待してはいけない
;一応全て式中関数ですが、TEMPSET等はCALLFと親和性があります
;こんな大掛かりなの用意しても誰も使わないって？　ハハハこやつめ
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;-------------------------------------------------
;テンポラリ関数@TEMPFLAG
;	引数0：フラグ番号
;	引数1：元関数の引数用
;	引数2：派生関数番号（内部処理用）
;テンポラリフラグを参照し、戻り値にします
;配列の数はLOCALの配列数の10倍まで引き受けます。つまりデフォルトで0～9999です
;変数置き場に困ったら、無駄に大量に管理できることを思い出してあげてください
;万一配列外になったら仕方ないので0を参照します
;-------------------------------------------------
@TEMPFLAG(ARG, ARG:1, ARG:2)
#FUNCTION

LOCAL = ARG/VARSIZE("LOCAL")
LOCAL:1 = ARG%VARSIZE("LOCAL")
;0～999（デフォルトの場合）
IF !LOCAL
	RETURNF TEMPFLAG_0(LOCAL:1, ARG:1, ARG:2)
;1000～1999
ELSEIF LOCAL == 1
	RETURNF TEMPFLAG_1(LOCAL:1, ARG:1, ARG:2)
;2000～2999
ELSEIF LOCAL == 2
	RETURNF TEMPFLAG_2(LOCAL:1, ARG:1, ARG:2)
;3000～3999
ELSEIF LOCAL == 3
	RETURNF TEMPFLAG_3(LOCAL:1, ARG:1, ARG:2)
;4000～4999
ELSEIF LOCAL == 4
	RETURNF TEMPFLAG_4(LOCAL:1, ARG:1, ARG:2)
;5000～5999
ELSEIF LOCAL == 5
	RETURNF TEMPFLAG_5(LOCAL:1, ARG:1, ARG:2)
;6000～6999
ELSEIF LOCAL == 6
	RETURNF TEMPFLAG_6(LOCAL:1, ARG:1, ARG:2)
;7000～7999
ELSEIF LOCAL == 7
	RETURNF TEMPFLAG_7(LOCAL:1, ARG:1, ARG:2)
;8000～8999
ELSEIF LOCAL == 8
	RETURNF TEMPFLAG_8(LOCAL:1, ARG:1, ARG:2)
;9000～9999
ELSEIF LOCAL == 9
	RETURNF TEMPFLAG_9(LOCAL:1, ARG:1, ARG:2)
ENDIF
RETURNF TEMPFLAG_0(LOCAL:1, ARG:1, ARG:2)

;-------------------------------------------------
;テンポラリ代入関数@TEMPSET
;	引数0：フラグ番号
;	引数1：セットする数字
;テンポラリフラグに引数1の値を代入します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPSET(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, ARG:1, 1)

;-------------------------------------------------
;テンポラリ初期化関数@TEMPRESET
;	引数0：フラグ番号の千の位
;	引数1：初期化する数字
;テンポラリフラグ配列を引数の数字で初期化します
;ただし1000区切りです。引数0に入れた数字を千の位とします（0なら0～999を初期化、但しLOCALがデフォの場合）
;その結果の数字（つまり引数まま）を返り値としますが、CALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPRESET(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG*1000, 2, ARG:1)

;-------------------------------------------------
;テンポラリ初期化関数@TEMPRESETALL
;	引数：初期化する数字
;テンポラリフラグ配列すべてを引数の数字で初期化します
;その結果の数字（つまり引数まま）を返り値としますが、CALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPRESETALL(ARG)
#FUNCTION
RETURNF (TEMPFLAG(0, 2, ARG) + TEMPFLAG(1000, 2, ARG) + TEMPFLAG(2000, 2, ARG) + TEMPFLAG(3000, 2, ARG) + TEMPFLAG(4000, 2, ARG) + TEMPFLAG(5000, 2, ARG) + TEMPFLAG(6000, 2, ARG) + TEMPFLAG(7000, 2, ARG) + TEMPFLAG(8000, 2, ARG) + TEMPFLAG(9000, 2, ARG))/10

;-------------------------------------------------
;テンポラリ加算関数@TEMPADD
;	引数0：フラグ番号
;	引数1：加算する数字
;テンポラリフラグに引数の値を加算します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPADD(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 3, ARG:1)

;-------------------------------------------------
;テンポラリ乗算関数@TEMPTIMES
;	引数0：フラグ番号
;	引数1：乗算する数字
;テンポラリフラグに引数の値を乗算しますが小数は使えません
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPTIMES(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 4, ARG:1)

;-------------------------------------------------
;テンポラリ除算関数@TEMPDIVISION
;	引数0：フラグ番号
;	引数1：除算する数字
;テンポラリフラグに引数の値を除算します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPDIVISION(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 5, ARG:1)

;-------------------------------------------------
;テンポラリ余り計算関数@TEMPDIVISORS
;	引数0：フラグ番号
;	引数1：除算する数字
;テンポラリフラグに引数の値を除算し、あまりを代入します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPDIVISORS(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 6, ARG:1)

;-------------------------------------------------
;テンポラリ累乗関数@TEMPPOWER
;	引数0：フラグ番号
;	引数1：除算する数字
;テンポラリフラグを引数乗します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPPOWER(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 7, ARG:1)

;-------------------------------------------------
;テンポラリビット取得関数@TEMPGETBIT
;	引数0：フラグ番号
;	引数1：ビット番号
;テンポラリフラグのビットを取得し、返り値とします。フラグを編集はしません
;-------------------------------------------------
@TEMPGETBIT(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 8, ARG:1)

;-------------------------------------------------
;テンポラリビット立て関数@TEMPSETBIT
;	引数0：フラグ番号
;	引数1：ビット番号
;テンポラリフラグの指定ビットを立てます
;その結果の数字（つまり1）を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPSETBIT(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 9, ARG:1)

;-------------------------------------------------
;テンポラリビット下げ関数@TEMPCLEARBIT
;	引数0：フラグ番号
;	引数1：ビット番号
;テンポラリフラグの指定ビットを降ろします
;その結果の数字（つまり0）を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPCLEARBIT(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 10, ARG:1)

;-------------------------------------------------
;テンポラリビット反転関数@TEMPINVERTBIT
;	引数0：フラグ番号
;	引数1：ビット番号
;テンポラリフラグの指定ビットを反転します
;その結果の数字を返り値としますが、不要ならCALLFで呼ぶといい感じです
;-------------------------------------------------
@TEMPINVERTBIT(ARG, ARG:1)
#FUNCTION
RETURNF TEMPFLAG(ARG, 11, ARG:1)

;-------------------------------------------------
;記入チェック関数@KOJO_WRITE
;	引数0：記入チェック内容
;	引数1：記入チェック番号
;	引数2：参照のみ
;テンポラリフラグの原理を利用して記入チェックを管理します
;CALLFで呼ぶといい感じです。初期化はしません
;-------------------------------------------------
@KOJO_WRITE(ARG, ARG:1, ARG:2)
#FUNCTION
SIF !ARG:2
	LOCAL:(ARG:1) = ARG
RETURNF LOCAL:(ARG:1)

;-------------------------------------------------
;記入チェック参照関数@KOJO_WROTE
;	引数：記入チェック番号
;テンポラリフラグの原理を利用して記入チェックを参照します
;-------------------------------------------------
@KOJO_WROTE(ARG)
#FUNCTION
RETURNF KOJO_WRITE(0, ARG, 1)


;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠通常関数
;eramakerで使われる通常の関数で、CALL系コマンドで呼び出して使用します
;基本的に、RESULT配列の値を書き換えます
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;-------------------------------------------------
;調教者交代関数@PLAYER_SWICH
;MASTER・ASSI間でPLAYERを交代します。ASSIPLAYも逆にします
;助手がいなくてもおかまいなし
;-------------------------------------------------
@PLAYER_SWICH
PLAYER = ASSIPLAY ? MASTER # ASSI
INVERTBIT ASSIPLAY, 0
RETURN RESULT


;-------------------------------------------------
;数値型インプット関数@INPUTINT
;　引数0～99：入力可能な数字
;数値の入力待ちをします。引数に含まれない数字を選んだら自動的に入力待ちをし直します
;有効な数字が入力されたらそれをRESULTへ返して戻ります
;選択肢を汎用処理するため、ループの構文を書く必要がなくなります
;-------------------------------------------------
@INPUTINT(ARG:0 = -147258369, ARG:1 = -147258369, ARG:2 = -147258369, ARG:3 = -147258369, ARG:4 = -147258369, ARG:5 = -147258369, ARG:6 = -147258369, ARG:7 = -147258369, ARG:8 = -147258369, ARG:9 = -147258369, ARG:10 = -147258369, ARG:11 = -147258369, ARG:12 = -147258369, ARG:13 = -147258369, ARG:14 = -147258369, ARG:15 = -147258369, ARG:16 = -147258369, ARG:17 = -147258369, ARG:18 = -147258369, ARG:19 = -147258369, ARG:20 = -147258369, ARG:21 = -147258369, ARG:22 = -147258369, ARG:23 = -147258369, ARG:24 = -147258369, ARG:25 = -147258369, ARG:26 = -147258369, ARG:27 = -147258369, ARG:28 = -147258369, ARG:29 = -147258369, ARG:30 = -147258369, ARG:31 = -147258369, ARG:32 = -147258369, ARG:33 = -147258369, ARG:34 = -147258369, ARG:35 = -147258369, ARG:36 = -147258369, ARG:37 = -147258369, ARG:38 = -147258369, ARG:39 = -147258369, ARG:40 = -147258369, ARG:41 = -147258369, ARG:42 = -147258369, ARG:43 = -147258369, ARG:44 = -147258369, ARG:45 = -147258369, ARG:46 = -147258369, ARG:47 = -147258369, ARG:48 = -147258369, ARG:49 = -147258369, ARG:50 = -147258369, ARG:51 = -147258369, ARG:52 = -147258369, ARG:53 = -147258369, ARG:54 = -147258369, ARG:55 = -147258369, ARG:56 = -147258369, ARG:57 = -147258369, ARG:58 = -147258369, ARG:59 = -147258369, ARG:60 = -147258369, ARG:61 = -147258369, ARG:62 = -147258369, ARG:63 = -147258369, ARG:64 = -147258369, ARG:65 = -147258369, ARG:66 = -147258369, ARG:67 = -147258369, ARG:68 = -147258369, ARG:69 = -147258369, ARG:70 = -147258369, ARG:71 = -147258369, ARG:72 = -147258369, ARG:73 = -147258369, ARG:74 = -147258369, ARG:75 = -147258369, ARG:76 = -147258369, ARG:77 = -147258369, ARG:78 = -147258369, ARG:79 = -147258369, ARG:80 = -147258369, ARG:81 = -147258369, ARG:82 = -147258369, ARG:83 = -147258369, ARG:84 = -147258369, ARG:85 = -147258369, ARG:86 = -147258369, ARG:87 = -147258369, ARG:88 = -147258369, ARG:89 = -147258369, ARG:90 = -147258369, ARG:91 = -147258369, ARG:92 = -147258369, ARG:93 = -147258369, ARG:94 = -147258369, ARG:95 = -147258369, ARG:96 = -147258369, ARG:97 = -147258369, ARG:98 = -147258369, ARG:99 = -147258369)
INPUT
SELECTCASE RESULT
	CASE ARG:0, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19, ARG:20, ARG:21, ARG:22, ARG:23, ARG:24, ARG:25, ARG:26, ARG:27, ARG:28, ARG:29, ARG:30, ARG:31, ARG:32, ARG:33, ARG:34, ARG:35, ARG:36, ARG:37, ARG:38, ARG:39, ARG:40, ARG:41, ARG:42, ARG:43, ARG:44, ARG:45, ARG:46, ARG:47, ARG:48, ARG:49, ARG:50, ARG:51, ARG:52, ARG:53, ARG:54, ARG:55, ARG:56, ARG:57, ARG:58, ARG:59, ARG:60, ARG:61, ARG:62, ARG:63, ARG:64, ARG:65, ARG:66, ARG:67, ARG:68, ARG:69, ARG:70, ARG:71, ARG:72, ARG:73, ARG:74, ARG:75, ARG:76, ARG:77, ARG:78, ARG:79, ARG:80, ARG:81, ARG:82, ARG:83, ARG:84, ARG:85, ARG:86, ARG:87, ARG:88, ARG:89, ARG:90, ARG:91, ARG:92, ARG:93, ARG:94, ARG:95, ARG:96, ARG:97, ARG:98, ARG:99
		RETURN RESULT
ENDSELECT
RESTART

;-------------------------------------------------
;数値型時間制限インプット関数@TINPUTINT
;	引数0：制限時間(ms)
;	引数1：時間切れ時の戻り値（デフォルトで-1）
;	引数2：=1だと残り時間を表示
;	引数3～22：入力可能な数字
;引数3以降で与えられた番号を有効な選択肢として数値の入力を受け付けます
;引数に含まれない数字だとやり直し。RESULTに選んだ値を返します
;-------------------------------------------------
@TINPUTINT(ARG:0, ARG:1 = -1, ARG:2, ARG:3 = -147258369, ARG:4 = -147258369, ARG:5 = -147258369, ARG:6 = -147258369, ARG:7 = -147258369, ARG:8 = -147258369, ARG:9 = -147258369, ARG:10 = -147258369, ARG:11 = -147258369, ARG:12 = -147258369, ARG:13 = -147258369, ARG:14 = -147258369, ARG:15 = -147258369, ARG:16 = -147258369, ARG:17 = -147258369, ARG:18 = -147258369, ARG:19 = -147258369, ARG:20 = -147258369, ARG:21 = -147258369, ARG:22 = -147258369, ARG:23 = -147258369, ARG:24 = -147258369, ARG:25 = -147258369, ARG:26 = -147258369, ARG:27 = -147258369, ARG:28 = -147258369, ARG:29 = -147258369, ARG:30 = -147258369, ARG:31 = -147258369, ARG:32 = -147258369, ARG:33 = -147258369, ARG:34 = -147258369, ARG:35 = -147258369, ARG:36 = -147258369, ARG:37 = -147258369, ARG:38 = -147258369, ARG:39 = -147258369, ARG:40 = -147258369, ARG:41 = -147258369, ARG:42 = -147258369, ARG:43 = -147258369, ARG:44 = -147258369, ARG:45 = -147258369, ARG:46 = -147258369, ARG:47 = -147258369, ARG:48 = -147258369, ARG:49 = -147258369, ARG:50 = -147258369, ARG:51 = -147258369, ARG:52 = -147258369, ARG:53 = -147258369, ARG:54 = -147258369, ARG:55 = -147258369, ARG:56 = -147258369, ARG:57 = -147258369, ARG:58 = -147258369, ARG:59 = -147258369, ARG:60 = -147258369, ARG:61 = -147258369, ARG:62 = -147258369, ARG:63 = -147258369, ARG:64 = -147258369, ARG:65 = -147258369, ARG:66 = -147258369, ARG:67 = -147258369, ARG:68 = -147258369, ARG:69 = -147258369, ARG:70 = -147258369, ARG:71 = -147258369, ARG:72 = -147258369, ARG:73 = -147258369, ARG:74 = -147258369, ARG:75 = -147258369, ARG:76 = -147258369, ARG:77 = -147258369, ARG:78 = -147258369, ARG:79 = -147258369, ARG:80 = -147258369, ARG:81 = -147258369, ARG:82 = -147258369, ARG:83 = -147258369, ARG:84 = -147258369, ARG:85 = -147258369, ARG:86 = -147258369, ARG:87 = -147258369, ARG:88 = -147258369, ARG:89 = -147258369, ARG:90 = -147258369, ARG:91 = -147258369, ARG:92 = -147258369, ARG:93 = -147258369, ARG:94 = -147258369, ARG:95 = -147258369, ARG:96 = -147258369, ARG:97 = -147258369, ARG:98 = -147258369, ARG:99 = -147258369, ARG:100 = -147258369, ARG:101 = -147258369, ARG:102 = -147258369)
TINPUT ARG, ARG:1, ARG:2
SELECTCASE RESULT
	CASE ARG:1, ARG:3, ARG:4, ARG:5, ARG:6, ARG:7, ARG:8, ARG:9, ARG:10, ARG:11, ARG:12, ARG:13, ARG:14, ARG:15, ARG:16, ARG:17, ARG:18, ARG:19, ARG:20, ARG:21, ARG:22, ARG:23, ARG:24, ARG:25, ARG:26, ARG:27, ARG:28, ARG:29, ARG:30, ARG:31, ARG:32, ARG:33, ARG:34, ARG:35, ARG:36, ARG:37, ARG:38, ARG:39, ARG:40, ARG:41, ARG:42, ARG:43, ARG:44, ARG:45, ARG:46, ARG:47, ARG:48, ARG:49, ARG:50, ARG:51, ARG:52, ARG:53, ARG:54, ARG:55, ARG:56, ARG:57, ARG:58, ARG:59, ARG:60, ARG:61, ARG:62, ARG:63, ARG:64, ARG:65, ARG:66, ARG:67, ARG:68, ARG:69, ARG:70, ARG:71, ARG:72, ARG:73, ARG:74, ARG:75, ARG:76, ARG:77, ARG:78, ARG:79, ARG:80, ARG:81, ARG:82, ARG:83, ARG:84, ARG:85, ARG:86, ARG:87, ARG:88, ARG:89, ARG:90, ARG:91, ARG:92, ARG:93, ARG:94, ARG:95, ARG:96, ARG:97, ARG:98, ARG:99, ARG:100, ARG:101, ARG:102
		RETURN RESULT
ENDSELECT
RESTART

;-------------------------------------------------
;複数ビットセット関数@SETBITS
;	引数0：セットする対象
;	引数1～100：セットに用いられる数値
;通常関数です。引数0の値に与えられた引数番目のビットを立てます
;-------------------------------------------------
@SETBITS(ARG, ARG:1 = -1, ARG:2 = -1, ARG:3 = -1, ARG:4 = -1, ARG:5 = -1, ARG:6 = -1, ARG:7 = -1, ARG:8 = -1, ARG:9 = -1, ARG:10 = -1, ARG:11 = -1, ARG:12 = -1, ARG:13 = -1, ARG:14 = -1, ARG:15 = -1, ARG:16 = -1, ARG:17 = -1, ARG:18 = -1, ARG:19 = -1, ARG:20 = -1, ARG:21 = -1, ARG:22 = -1, ARG:23 = -1, ARG:24 = -1, ARG:25 = -1, ARG:26 = -1, ARG:27 = -1, ARG:28 = -1, ARG:29 = -1, ARG:30 = -1, ARG:31 = -1, ARG:32 = -1, ARG:33 = -1, ARG:34 = -1, ARG:35 = -1, ARG:36 = -1, ARG:37 = -1, ARG:38 = -1, ARG:39 = -1, ARG:40 = -1, ARG:41 = -1, ARG:42 = -1, ARG:43 = -1, ARG:44 = -1, ARG:45 = -1, ARG:46 = -1, ARG:47 = -1, ARG:48 = -1, ARG:49 = -1, ARG:50 = -1, ARG:51 = -1, ARG:52 = -1, ARG:53 = -1, ARG:54 = -1, ARG:55 = -1, ARG:56 = -1, ARG:57 = -1, ARG:58 = -1, ARG:59 = -1, ARG:60 = -1, ARG:61 = -1, ARG:62 = -1, ARG:63 = -1, ARG:64 = -1, ARG:65 = -1, ARG:66 = -1, ARG:67 = -1, ARG:68 = -1, ARG:69 = -1, ARG:70 = -1, ARG:71 = -1, ARG:72 = -1, ARG:73 = -1, ARG:74 = -1, ARG:75 = -1, ARG:76 = -1, ARG:77 = -1, ARG:78 = -1, ARG:79 = -1, ARG:80 = -1, ARG:81 = -1, ARG:82 = -1, ARG:83 = -1, ARG:84 = -1, ARG:85 = -1, ARG:86 = -1, ARG:87 = -1, ARG:88 = -1, ARG:89 = -1, ARG:90 = -1, ARG:91 = -1, ARG:92 = -1, ARG:93 = -1, ARG:94 = -1, ARG:95 = -1, ARG:96 = -1, ARG:97 = -1, ARG:98 = -1, ARG:99 = -1, ARG:100 = -1)
LOCAL = 0
FOR LOCAL:100, 1, 100
	SIF ARG:(LOCAL:100) < 0 || ARG:(LOCAL:100) > 63
		RETURN RESULT
	SETBIT ARG, ARG:(LOCAL:100)
NEXT
RETURN RESULT

;-------------------------------------------------
;表示テキスト保管関数@STRBANK
;	文字列引数：保存する文面（空文字列可）
;	引数0：改行情報。0で改行なし、1で改行、2でクリック待ち、3でテキスト放出して廃棄、4で放出、5で廃棄（3以上のとき文字列引数は無視する）
;	引数1：文字色情報。0で指定なし、1で一行デフォカラー、2で一行カラー指定、3でカラー指定しつつ、そのカラーを維持する（表示が終わっても戻らない）
;	引数2：文字色指定。引数2が2か3だった場合に参照される。式中関数@RGBCOLORに対応
;繰り返し呼ぶことで文字列をLOCALSに蓄えていき、引数で指定したときにすべて表示します。
;表示方法は代入するときに指定可能。1000行まで引き受けるよ！
;カラー指定は行単位でのみ可能。同じ行で複数回指定された場合、最後の指定を優先。フォント指定は何かと問題起こすんでオミットしてます
;@STRBANKL～@STRDRAWを経由して使われるのを想定していますが、直接呼ばなきゃできない操作もあります。
;-------------------------------------------------
;@STRBANK(ARGS, ARG, ARG:1, ARG:2)
;#LOCALSIZE 1000
;#LOCALSSIZE 1000
;#DIM COLORDATA, 1000
;#DIM COLORNUM, 1000
;#DIM SET_LOCALS, 1
;#DIM LCOUNT, 2
;;初期設定
;IF !SET_LOCALS
;	VARSET LOCALS, "＠＠NODATA＠＠"
;	VARSET LOCAL
;	SET_LOCALS = 1
;ENDIF
;;預金
;IF ARG < 3
;	FOR LCOUNT, 0, 1000
;		IF !LOCAL:LCOUNT
;			IF LOCALS:LCOUNT == "＠＠NODATA＠＠"
;				LOCALS:LCOUNT = %ARGS%
;			ELSE
;				LOCALS:LCOUNT = %LOCALS:LCOUNT + ARGS%
;			ENDIF
;			LOCAL:LCOUNT = ARG
;			COLORDATA:LCOUNT = ARG:1
;			COLORNUM:LCOUNT = ARG:2
;			BREAK
;		ENDIF
;	NEXT
;;引き出し
;ELSE
;	IF ARG < 5
;		FOR LCOUNT, 0, 1000
;			SIF LOCALS:LCOUNT == "＠＠NODATA＠＠"
;				BREAK
;			SELECTCASE COLORDATA:LCOUNT
;				CASE 0
;					PRINTS LOCALS:LCOUNT
;				CASE 1
;					PRINTSD LOCALS:LCOUNT
;				CASE 2
;					LCOUNT:1 = GETCOLOR()
;					SETCOLOR COLORNUM:LCOUNT
;					PRINTS LOCALS:LCOUNT
;					SETCOLOR LCOUNT:1
;				CASE 3
;					SETCOLOR COLORNUM:LCOUNT
;					PRINTS LOCALS:LCOUNT
;			ENDSELECT
;			SELECTCASE LOCAL:LCOUNT
;				CASE 1
;					PRINTL 
;				CASE 2
;					PRINTW 
;			ENDSELECT
;		NEXT
;	ENDIF
;	IF ARG != 4
;		VARSET LOCALS, "＠＠NODATA＠＠"
;		VARSET LOCAL
;	ENDIF
;ENDIF
;RETURN RESULT

;@STRBANKL(ARGS)
;CALL STRBANK(ARGS, 1)
;RETURN RESULT
;@STRBANKW(ARGS)
;CALL STRBANK(ARGS, 2)
;RETURN RESULT
;@STRBANKDL(ARGS)
;CALL STRBANK(ARGS, 1, 1)
;RETURN RESULT
;@STRBANKDW(ARGS)
;CALL STRBANK(ARGS, 2, 1)
;RETURN RESULT
;@STRBANKCL(ARGS, ARG)
;CALL STRBANK(ARGS, 1, 2, ARG)
;RETURN RESULT
;@STRBANKCW(ARGS, ARG)
;CALL STRBANK(ARGS, 2, 2, ARG)
;RETURN RESULT
;@STRDRAW(ARG)
;CALL STRBANK("", ARG + 3)
;RETURN RESULT

;--------------------------------------------------
;相性検索関数@RELATION_QUERY
;	引数0：対象のキャラ番号（登録番号ではない。手元に存在している必要はない）
;	引数1：検索条件（0=指定しない, 1=手元にいないキャラのみ選ぶ, 2=手元にいるキャラのみ選ぶ）
;対象キャラと全キャラとの相性を検索して、最も相性の良い相手を抽出します
;--------------------------------------------------
;戻り値一覧
;	RESULT：発見されたキャラとの相性（0=発見不可, 1=対象への相性101～199, 2=対象への相性200以上）
;	RESULT:1：発見したキャラのキャラ番号（発見不可の場合=-1）
;	RESULT:2：発見したキャラの登録番号（手元にいない場合=-1）
;	RESULTS：発見したキャラの呼び名
;	RESULTS:1：発見したキャラの名前
;--------------------------------------------------
@RELATION_QUERY(ARG, ARG:1)
;検索対象の登録番号を抽出
LOCAL = GETCHARA(ARG, 1)
LOCAL:6 = 0
IF LOCAL == -1
	ADDCHARA ARG
	LOCAL = CHARANUM - 1
	LOCAL:6 = 1
ENDIF
LOCAL:1 = -1
IF ARG:1 == 2
	;手元から検索
	FOR LOCAL:100, 0, CHARANUM
		LOCAL:2 = LOCAL:1 < 0 ? 100 # RELATION:LOCAL:(LOCAL:1)
		LOCAL:3 = NO:(LOCAL:100) < 0 || NO:(LOCAL:100) >= VARSIZE("RELATION") ? 100 # RELATION:LOCAL:(NO:(LOCAL:100))
		SIF LOCAL:2 == 0
			LOCAL:2 = 100
		SIF LOCAL:3 == 0
			LOCAL:3 = 100
		;同値の場合ランダムで残す
		;後に引いたほうが大きい場合それを保存
		SIF (LOCAL:2 == LOCAL:3 && RAND:2 && LOCAL:1 >= 0) || LOCAL:2 < LOCAL:3
			LOCAL:1 = NO:(LOCAL:100)
	NEXT
ELSE
	;全体から検索
	;相性を総検索しキャラ番号と相性値を抽出
	FOR LOCAL:100, 0, VARSIZE("RELATION")
		;そもそもCSVがないなら見る必要なし
		SIF EXISTCSV(LOCAL:100, 0)  == 0
			CONTINUE
		;キャラがいるか確認して、いるかつ検索条件=1なら次へ飛ぶ
		SIF GETCHARA(LOCAL:100, 1) != -1 && ARG:1 == 1
			CONTINUE
		LOCAL:2 = LOCAL:1 < 0 ? 100 # RELATION:LOCAL:(LOCAL:1)
		LOCAL:3 = RELATION:LOCAL:(LOCAL:100)
		SIF LOCAL:2 == 0
			LOCAL:2 = 100
		SIF LOCAL:3 == 0
			LOCAL:3 = 100
		;同値の場合ランダムで残す
		;後に引いたほうが大きい場合それを保存
		SIF ((LOCAL:2 == LOCAL:3 && RAND:2 && LOCAL:1 >= 0) || LOCAL:2 < LOCAL:3) && LOCAL:100 < 149
			LOCAL:1 = LOCAL:100
	NEXT
ENDIF
SIF LOCAL:6
	DELCHARA CHARANUM - 1

;名前と登録番号を取得
RESULT:1 = LOCAL:1
IF LOCAL:1 >= 0
	RESULT:2 = GETCHARA(LOCAL:1, 1)
	IF RESULT:2 >= 0
		RESULTS = %CALLNAME:(RESULT:2)%
		RESULTS:1 = %NAME:(RESULT:2)%
	ELSE
		RESULTS = %CSVCALLNAME(LOCAL:1, 0)%
		RESULTS:1 = %CSVNAME(LOCAL:1, 0)%
	ENDIF
ENDIF
;数値に応じてRETURN
SIF RELATION:LOCAL:(LOCAL:1) > 199
	RETURN 2
SIF RELATION:LOCAL:(LOCAL:1) > 100
	RETURN 1
RETURN 0

;--------------------------------------------------
;絶頂強度算出関数@ECST_LEVEL
;CVAB各絶頂の強度を返します。それ以外の絶頂には対応しません。
;多重絶頂の倍率が違うバリアントにも対応できません。
;--------------------------------------------------
;戻り値一覧
;	RESULT：何重絶頂か（0～4）
;	RESULT:1：Ｃ絶頂（1=絶頂, 2=強絶頂, 4=超強絶頂, 9=最強絶頂）
;	RESULT:2：Ｖ絶頂（1=絶頂, 2=強絶頂, 4=超強絶頂, 9=最強絶頂）
;	RESULT:3：Ａ絶頂（1=絶頂, 2=強絶頂, 4=超強絶頂, 9=最強絶頂）
;	RESULT:4：Ｂ絶頂（1=絶頂, 2=強絶頂, 4=超強絶頂, 9=最強絶頂）
;	RESULT:5：強精神薬での空絶頂（ビット演算：1=Ｃ, 2=Ｖ, 4=Ａ, 8=Ｂ絶頂キャンセル）
;--------------------------------------------------
@ECST_LEVEL
;何重絶頂か計算する
LOCAL = 0
SIF NOWEXCHECK(TARGET, "Ｃ絶頂")
	LOCAL += 1
SIF NOWEXCHECK(TARGET, "Ｖ絶頂")
	LOCAL += 1
SIF NOWEXCHECK(TARGET, "Ａ絶頂")
	LOCAL += 1
SIF NOWEXCHECK(TARGET, "Ｂ絶頂")
	LOCAL += 1

;イっているなら各絶頂の強度を算出
IF LOCAL
	RESULT:1 = NOWEXCHECK(TARGET, "Ｃ絶頂") / POWER(2, LOCAL-1)
	RESULT:2 = NOWEXCHECK(TARGET, "Ｖ絶頂") / POWER(2, LOCAL-1)
	RESULT:3 = NOWEXCHECK(TARGET, "Ａ絶頂") / POWER(2, LOCAL-1)
	RESULT:4 = NOWEXCHECK(TARGET, "Ｂ絶頂") / POWER(2, LOCAL-1)
ENDIF

;強精神薬判定
IF ITEMCHECK("強精神薬")
	RESULT:5 = 0
	SIF DOWN:COUNT > 0 && NOWEX:COUNT == 0
		SETBIT RESULT:5, COUNT
ENDIF
RETURN LOCAL

;-------------------------------------------------
;ハートマーク関数@HEART
;	引数0：ハートの数（省略すると1つ）
;	引数1：使用するフォント名（省略するとVerdana）
;中抜きのハートマークを表示します
;-------------------------------------------------
;@HEART(ARG, ARGS)
;LOCAL = RESULT
;ARGS = \@ ARGS == "" ? Verdana # %ARGS% \@
;LOCALS = %GETFONT()%

;SETFONT CHKFONT(ARGS) ? ARGS # LOCALS

;CALL SYMBOLPRINT(ARG, UNICODE(0x2661))

;SETFONT LOCALS
;RETURN LOCAL

;-------------------------------------------------
;入力待ちハートマーク関数@HEARTW
;	引数0：ハートの数（省略すると1つ）
;	引数1：使用するフォント名（省略するとVerdana）
;	引数2：『」』の代わりに表示する文字列
;	引数3：真にすると、『」』を表示しない
;中抜きハートマークを表示してから『」』を表示し、入力待ち・改行をします
;-------------------------------------------------
;@HEARTW(ARG, ARGS, ARGS:1, ARG:1)
;CALL HEART(ARG, ARGS)
;SIF !ARG:1
;	ARGS:1 = \@ ARGS:1 == "" ? 」 # %ARGS:1% \@
;PRINTSW ARGS:1
;RETURN RESULT

;-------------------------------------------------
;黒ハートマーク関数@HEARTB
;	引数0：ハートの数（省略すると1つ）
;	引数1：使用するフォント名（省略するとSymbol）
;塗りつぶしのハートマークを表示します
;-------------------------------------------------
;@HEARTB(ARG, ARGS)
;LOCAL = RESULT
;IF CHKFONT("Symbol")
;	ARGS = \@ ARGS == "" ? Symbol # %ARGS% \@
;ELSEIF CHKFONT("Verdana")
;	ARGS = \@ ARGS == "" ? Verdana # %ARGS% \@
;ENDIF
;LOCALS = %GETFONT()%

;SETFONT CHKFONT(ARGS) ? ARGS # LOCALS

;IF GETFONT() == "Symbol"
;	CALL SYMBOLPRINT(ARG, UNICODE(0xA9))
;ELSE
;	CALL SYMBOLPRINT(ARG, UNICODE(0x2665))
;ENDIF

;SETFONT LOCALS
;RETURN LOCAL

;-------------------------------------------------
;入力待ち黒ハートマーク関数@HEARTBW
;	引数0：ハートの数（省略すると1つ）
;	引数1：使用するフォント名（省略するとSymbol）
;	引数2：『」』の代わりに表示する文字列
;	引数3：真にすると、『」』を表示しない
;塗りつぶしハートマークを表示してから『」』を表示し、入力待ち・改行をします
;-------------------------------------------------
;@HEARTBW(ARG, ARGS, ARGS:1, ARG:1)
;CALL HEARTB(ARG, ARGS)
;SIF !ARG:1
;	ARGS:1 = \@ ARGS:1 == "" ? 」 # %ARGS:1% \@
;PRINTSW ARGS:1
;RETURN RESULT

;-------------------------------------------------
;ハートマーク系デフォルトカラー関数@HEARTD～系
;上記と同じバリエーションがありますが、デフォルトの文字色で表示します
;また、こちらで呼ぶと入力待ちハート系の『」』がデフォルトで表示されません。つまり地の分向け
;引数3を真にすれば逆に『」』を表示するようになります
;-------------------------------------------------
;@HEARTD(ARG, ARGS)
;LOCAL = GETCOLOR()
;RESETCOLOR
;CALL HEART(ARG, ARGS)
;SETCOLOR LOCAL
;RETURN RESULT

;@HEARTDW(ARG, ARGS, ARGS:1, ARG:1)
;LOCAL = GETCOLOR()
;RESETCOLOR
;CALL HEARTW(ARG, ARGS, ARGS:1, !ARG:1)
;SETCOLOR LOCAL
;RETURN RESULT

;@HEARTDB(ARG, ARGS)
;LOCAL = GETCOLOR()
;RESETCOLOR
;CALL HEARTB(ARG, ARGS)
;SETCOLOR LOCAL
;RETURN RESULT

;@HEARTDBW(ARG, ARGS, ARGS:1, ARG:1)
;LOCAL = GETCOLOR()
;RESETCOLOR
;CALL HEARTBW(ARG, ARGS, ARGS:1, !ARG:1)
;SETCOLOR LOCAL
;RETURN RESULT

;-------------------------------------------------
;口上色指定文字列表示関数@PRINTCOLOR～系
;	引数0：文字色
;	引数1：文字列
;指定した文字色で文字列を表示します。カラー指定は16進ですが、RGBCOLOR関数を利用することができます
;PRINT命令同様の「PRINTCOLORL」「PRINTCOLORW」もありますが、書式は面倒です
;例えば…
;CALL PRINTCOLORW(RGBCOLOR(255, 0, 0), "この文字列は赤く表示されて改行待ちをします。")
;-------------------------------------------------
;@PRINTCOLOR(ARG, ARGS, ARG:1)
;LOCAL = GETCOLOR()
;SETCOLOR ARG
;PRINTFORM %ARGS%
;IF ARG:1 == 1
;	PRINTL 
;ELSEIF ARG:2 == 2
;	PRINTW 
;ENDIF
;SETCOLOR LOCAL
;RETURN RESULT

;@PRINTCOLORL(ARG, ARGS)
;CALL PRINTCOLOR(ARG, ARGS, 1)
;RETURN RESULT

;@PRINTCOLORW(ARG, ARGS)
;CALL PRINTCOLOR(ARG, ARGS, 2)
;RETURN RESULT

;-------------------------------------------------
;文字列スクロール関数@SCROLLTEXT
;	文字列引数：スクロールさせる文字列
;	引数0：1にするとスクロール中、文字列の下にDRAWLINEします。2だと-=ラインに
;	引数1：スクロール速度（デフォルトだと30）
;	引数2：ウィンドウの横に入る文字数（デフォルトだと82）
;	引数3：真にすると文字列が端でバウンドします。数字を上げるとバウンドが緩くなります。誰が得するんだよこの機能
;	引数4：真にするとスクロール方向が逆になります。デフォルトだと左から右。SCROLLTEXTLというエイリアスが存在
;引数の文字列をスクロールさせます
;-------------------------------------------------
;@SCROLLTEXT(ARGS, ARG, ARG:1 = 30, ARG:2 = 82, ARG:3, ARG:4)
;LOCALS = %ARGS%
;;スペースを付加
;IF ARG:4
;	ARGS = %(" "*ARG:2)+ARGS%
;ELSE
;	ARGS = %" "*(ARG:2 - 2 - STRLENS(ARGS))+ARGS%
;ENDIF
;;スクロール速度がウィンドウ幅に対し速すぎる場合、矯正する
;ARG:1 = ARG:1 >= ARG:2 ? ARG:2-1 # ARG:1
;REDRAW 0
;LOCAL = 0
;FOR LOCAL, 0, ARG:2-2, ARG:1
;	IF ARG:4
;		PRINTSINGLEFORM %SUBSTRING(ARGS , LOCAL)%
;	ELSE
;		PRINTSINGLEFORM %SUBSTRING(ARGS , (ARG:2 - 2) - LOCAL)%
;	ENDIF
;	IF ARG == 1
;		DRAWLINE
;	ELSEIF ARG == 2
;		CUSTOMDRAWLINE -=
;	ENDIF
;	TWAIT 2 , 1
;	CLEARLINE 1+!(!ARG)
;NEXT
;;ばうんど。おまけ機能なんで適当なんだZE☆ミ
;IF ARG:3
;	FOR LOCAL, ARG:3, ARG:3*5, ARG:3*2
;		IF ARG:4
;			PRINTFORML %LOCALS%
;		ELSE
;			PRINTFORML %ARGS%
;		ENDIF
;		IF ARG == 1
;			DRAWLINE
;		ELSEIF ARG == 2
;			CUSTOMDRAWLINE -=
;		ENDIF
;		TWAIT 2 , 1
;		CLEARLINE 1+!(!ARG)
;		FOR LOCAL:1, 0, ARG:2/(LOCAL+4), ARG:1/(LOCAL+1)
;			IF ARG:4
;				PRINTSINGLEFORM %SUBSTRING(ARGS , ARG:2 - LOCAL:1)%
;			ELSE
;				PRINTSINGLEFORM %SUBSTRING(ARGS , LOCAL:1)%
;			ENDIF
;			IF ARG == 1
;				DRAWLINE
;			ELSEIF ARG == 2
;				CUSTOMDRAWLINE -=
;			ENDIF
;			TWAIT 2 , 1
;			CLEARLINE 1+!(!ARG)
;		NEXT
;		FOR LOCAL:2, 0, ARG:2/(LOCAL+4), ARG:1/(LOCAL+1)
;			IF ARG:4
;				PRINTSINGLEFORM %SUBSTRING(ARGS , ARG:2 - LOCAL:1 + LOCAL:2)%
;			ELSE
;				PRINTSINGLEFORM %SUBSTRING(ARGS , LOCAL:1 - LOCAL:2)%
;			ENDIF
;			IF ARG == 1
;				DRAWLINE
;			ELSEIF ARG == 2
;				CUSTOMDRAWLINE -=
;			ENDIF
;			TWAIT 2 , 1
;			CLEARLINE 1+!(!ARG)
;		NEXT
;	NEXT
;ENDIF

;IF ARG:4
;	PRINTFORML %LOCALS%
;ELSE
;	PRINTFORML %ARGS%
;ENDIF
;IF ARG == 1
;	DRAWLINE
;ELSEIF ARG == 2
;	CUSTOMDRAWLINE -=
;ENDIF
;REDRAW 1
;RETURN RESULT

;-------------------------------------------------
;文字列右スクロール関数@SCROLLTEXTL
;	文字列引数：スクロールさせる文字列
;	引数0：真にするとスクロール中、文字列の下にDRAWLINEします
;	引数1：スクロール速度（デフォルトだと30）
;	引数2：ウィンドウの横に入る文字数（デフォルトだと82）
;	引数3：真にすると文字列が端でバウンドします。数字を上げるとバウンドが緩くなります。誰が得するんだよこの機能
;引数の文字列をウィンドウの右から左へスクロールさせます
;-------------------------------------------------
;@SCROLLTEXTL(ARGS, ARG, ARG:1 = 30, ARG:2 = 82, ARG:3)
;CALL SCROLLTEXT(ARGS, ARG, ARG:1, ARG:2, ARG:3, 1)
;RETURN RESULT

;-------------------------------------------------
;全キャラ追加関数@ADDALLCHARA
;	csv定義されている全てのキャラをいっせいに追加します。
;	キャラを削除せずに管理するタイプのバリアントで有効となります
;	引数は追加するキャラ番号の上限値とCFLAG:0の値。要するにSPキャラフラグを生存判定にする場合のオプション
;-------------------------------------------------
@ADDALLCHARA(ARG, ARG:1)
#DIM LCOUNT, 1
FOR LCOUNT, 0, ARG
	IF EXISTCSV(LCOUNT, 0) && GETCHARA(LCOUNT) < 0
		ADDCHARA LCOUNT
		CFLAG:(CHARANUM-1):0 = ARG:1
	ENDIF
NEXT

;-------------------------------------------------
;再描画関数@SAVELINE/@RETURNLINE
;	SAVELINEしてからRETURNLINEすると、SAVELINEしたところまで行削除します。
;	メニューの再描画とかにご利用くだしあ
;	SAVELINE忘れてRETURNLINEするとカオスになるぞ！
;-------------------------------------------------
;@SAVELINE(ARG)
;IF ARG
;	CLEARLINE LINECOUNT-LOCAL
;ELSE
;	LOCAL = LINECOUNT-1
;ENDIF
;RETURN RESULT

;@RETURNLINE
;CALL SAVELINE, 1
;RETURN RESULT

;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡
;＠内部関数
;バリアント互換のためなどでぱんくしょん内部で使用される子関数・孫関数です
;使用することもできますが原則非推奨です
;≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡

;--------------------------------------------------
;能力判定関数@ABLCHECK
;引数：対象のキャラ登録番号, 能力名
;全ABLNAMEと照合して数値を返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@ABLCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(ABL, ARGS)
RETURNF LOCAL >= 0 ? ABL:ARG:LOCAL # 0

;--------------------------------------------------
;素質判定関数@TALENTCHECK
;引数：対象のキャラ登録番号, 能力名
;全TALENTNAMEと照合して数値を返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@TALENTCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(TALENT, ARGS)
RETURNF LOCAL >= 0 ? TALENT:ARG:LOCAL # 0

;--------------------------------------------------
;経験判定関数@EXPCHECK
;引数：対象のキャラ登録番号, 経験名
;全EXPNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@EXPCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(EXP, ARGS)
RETURNF LOCAL >= 0 ? EXP:ARG:LOCAL # 0

;--------------------------------------------------
;刻印判定関数@MARKCHECK
;引数：対象のキャラ登録番号, 刻印名
;全MARKNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@MARKCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(MARK, ARGS)
RETURNF LOCAL >= 0 ? MARK:ARG:LOCAL # 0

;--------------------------------------------------
;パラメータ判定関数@PALAMCHECK
;引数：対象のキャラ登録番号, パラメータ名
;全PALAMNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@PALAMCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(PALAM, ARGS)
RETURNF LOCAL >= 0 ? PALAM:ARG:LOCAL # 0

;--------------------------------------------------
;アイテム判定関数@ITEMCHECK
;引数：アイテム名
;全ITEMNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@ITEMCHECK(ARGS)
#FUNCTION
LOCAL = GETNUM(ITEM, ARGS)
RETURNF LOCAL >= 0 ? ITEM:LOCAL # 0

;--------------------------------------------------
;絶頂判定関数@EXCHECK
;引数：対象のキャラ登録番号, 経験名
;全EXNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@EXCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(EX, ARGS)
RETURNF LOCAL >= 0 ? EX:ARG:LOCAL # 0

;--------------------------------------------------
;調教内絶頂判定関数@NOWEXCHECK
;引数：対象のキャラ登録番号, 経験名
;全EXNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@NOWEXCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(EX, ARGS)
RETURNF LOCAL >= 0 ? NOWEX:ARG:LOCAL # 0

;--------------------------------------------------
;ソース判定関数@SOURCECHECK
;引数：対象のキャラ登録番号, ソース
;全SOURCENAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@SOURCECHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(SOURCE, ARGS)
RETURNF LOCAL >= 0 ? SOURCE:ARG:LOCAL # 0

;--------------------------------------------------
;EQUIP判定関数@EQUIPCHECK
;引数：対象のキャラ登録番号, EQUIP
;全EQUIPNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@EQUIPCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(EQUIP, ARGS)
RETURNF LOCAL >= 0 ? EQUIP:ARG:LOCAL # 0

;--------------------------------------------------
;TEQUIP判定関数@TEQUIPCHECK
;引数：対象のキャラ登録番号, TEQUIP
;全TEQUIPNAMEと照合して返します。
;存在しない場合、0が返ります。
;--------------------------------------------------
@TEQUIPCHECK(ARG, ARGS)
#FUNCTION
LOCAL = GETNUM(TEQUIP, ARGS)
RETURNF LOCAL >= 0 ? TEQUIP:ARG:LOCAL # 0

;-------------------------------------------------
;記号表示関数@SYMBOLPRINT
;内部的に使う関数です。呼び出さないでください
;-------------------------------------------------
;@SYMBOLPRINT(ARG, ARGS)
;ARG = !ARG ? 1 # ARG
;FOR LOCAL:100, 0, ARG
;	PRINTS ARGS
;NEXT
;RETURN RESULT

;-------------------------------------------------------------------------------
;	TIMESの式中関数版TIMESF(式中関数)
;-------------------------------------------------------------------------------
;	例  LOCAL = TIMESF(100,200)
;       この場合 100 * 2.00 + 0 = 200
;===============================================================================
@TIMESF(ARG, ARG:1, ARG:2)
#FUNCTION
; とりあえず0から1兆
RETURNF LIMIT((ARG * ARG:1 / 100) + ARG:2, 0, 999999999999)

;-------------------------------------------------
;初回判定処理関数@FIRSTTIME_PROCESS
;	引数0：使用するCFLAGスコープの始点
;	引数1：使用するCFLAGの数（引数0が7000、引数1が20なら、7000～7019の20個を消費する）
;	引数2：イベント・コマンド番号
;	引数3：対象キャラの簡易指定（0=TARGET, 1=MASTER, 2=ASSI, 3=引数2で指定したキャラ）
;	引数4：引数3が=3のとき、対象キャラの登録番号
;	引数5：真の場合、初回判定を参照するのみで更新しない
;CFLAGによる初回判定系の関数の処理を一括して行います
;63*フラグ使用数、の初回判定枠がプールされる（フラグを20確保した場合、63*20で0～1259の1260通り使える）
;-------------------------------------------------
@FIRSTTIME_PROCESS(ARG, ARG:1, ARG:2, ARG:3, ARG:4, ARG:5)
#FUNCTION
IF !ARG:3
	ARG:4 = TARGET
ELSEIF ARG:3 == 1
	ARG:4 = MASTER
ELSEIF ARG:3 == 2
	ARG:4 = ASSI
ENDIF
;規定の数を超えるか負か対象キャラがいないかスコープが負なら0を返す
SIF ARG:2 >= ARG:1*63 || ARG:2 < 0 || ARG:4 < 0 || PANCTION_CFLAG(0) < 0
	RETURNF 0

LOCAL = ARG + ARG:2/63
ARG:2 %= 63

IF !GETBIT(CFLAG:(ARG:4):LOCAL, ARG:2)
	SIF !ARG:5
		SETBIT CFLAG:(ARG:4):LOCAL, ARG:2
	RETURNF 1
ENDIF
RETURNF 0

;-------------------------------------------------
;調教内初回判定初期化関数@ONCEPLAYRESET
;	引数0：対象キャラの簡易指定（0=TARGET, 1=MASTER, 2=ASSI, 3=引数2で指定したキャラ, 4=すべてのキャラ）
;	引数1：引数3が=3のとき、対象キャラの登録番号
;@ONCEPLAYの初回判定をリセットします
;-------------------------------------------------
@ONCEPLAYRESET(ARG, ARG:1)
RETURN ONCEPLAY(0, ARG, ARG:1, 0, ARG == 4 ? 2 # 1)

;デフォルトのフラグリセッタ（全キャラ）
@EVENTTRAIN
#PRI
CALL ONCEPLAYRESET(4)

;-------------------------------------------------
;テンポラリ保存関数@TEMPFLAG_0～9
;	引数0：フラグ番号
;	引数1：元関数の引数用
;	引数2：派生関数番号（内部処理用）
;テンポラリフラグを保存するための関数群です
;-------------------------------------------------
@TEMPFLAG_0(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_1(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_2(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_3(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_4(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_5(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_6(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_7(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_8(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG

@TEMPFLAG_9(ARG, ARG:1, ARG:2)
#FUNCTION
;SET
IF ARG:2 == 1
	LOCAL:ARG = ARG:1
;RESET
ELSEIF ARG:2 == 2
	VARSET LOCAL, ARG:1
;ADD
ELSEIF ARG:2 == 3
	LOCAL:ARG += ARG:1
;TIMES
ELSEIF ARG:2 == 4
	LOCAL:ARG *= ARG:1
;DIVISION
ELSEIF ARG:2 == 5
	LOCAL:ARG /= ARG:1
;DIVISORS
ELSEIF ARG:2 == 6
	LOCAL:ARG %= ARG:1
;POWER
ELSEIF ARG:2 == 7
	POWER LOCAL:ARG, LOCAL:ARG, ARG:1
;GETBIT
ELSEIF ARG:2 == 8
	RETURNF GETBIT(LOCAL:ARG, ARG:1)
;SETBIT
ELSEIF ARG:2 == 9
	SETBIT LOCAL:ARG, ARG:1
;CLEARBIT
ELSEIF ARG:2 == 10
	CLEARBIT LOCAL:ARG, ARG:1
;INVERTBIT
ELSEIF ARG:2 == 11
	INVERTBIT LOCAL:ARG, ARG:1
ENDIF
RETURNF LOCAL:ARG
